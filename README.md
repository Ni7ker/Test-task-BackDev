***Test-task-BackDev***
Тестовое задание на позицию Junior Backend Developer

**Как запустить:**
1. Запустить Docker Desktop
2. Прописать в CLI: docker compose up -d
3. Для просмотра логов: docker logs medods-auth-app-1

**Как протестировать:**
*Перейти в Postman*
*Прописать:*
Либо GET-запрос на localhost:8080/auth с указанием хедера Name (выбранный вариант параметра для аунтификации). Ответ:
Параметр аунтификации
JWT-token лишь для наглядности
Незашифрованный refresh-token
Что происходит:
В куки устанавливается jwt и refresh-token устанавливаются в качестве инструкции к куки на стороне клиента по пути /api/auth. JWT в body, Refresh строго в HttpOnly, также устанавливаются их ttl
В базу заноситься параметр аутификации, зашифрованный в bcrypt refresh-token и момент создания refresh-token
Стоит заметить, что процесс добавления сессии в таблицу имеет свои меры безопасности. При добавлении проверятся сколько рефреш-сессий всего есть у юзера и, если их больше одной (для примера) или юзер конектится одновременно из нескольких подсетей, стоит предпринять меры. Имплементируя данную проверку, я проверяю только что бы юзер имел максимум 1 одновременных рефреш-сессий, и при попытке установить следующую удаляю предыдущую. Таким образом если юзер залогинился на пяти устройствах, рефреш токены будут постоянно обновляться и все счастливы. Но если с аккаунтом юзера начнут производить подозрительные действия(попытаются залогинится более чем на одном устройстве) система сбросит все сессии(рефреш токены).
Либо POST-запрос на localhost:8080/refresh с хедерами Name (тот же, на который получен токен) и Token (полученный ранее токен). Ответ:
Параметр аунтификации
JWT-token лишь для наглядности
Незашифрованный refresh-token
Что происходит:
Сверяются полученный токен и расшифрованный токен из базы
Проверяю "жив" ли ещё токен
В случае успеха обновляю рефреш-сессию в базе создав новый refresh-token и зашифровав его, также обновляю куки

**Используемые технологии:**

- Go
- JWT
- PostgreSQL

**Задание:**

Написать часть сервиса аутентификации.

Два REST маршрута:

- Первый маршрут выдает пару Access, Refresh токенов для пользователя с идентификатором (GUID) указанным в параметре запроса
- Второй маршрут выполняет Refresh операцию на пару Access, Refresh токенов

**Требования:**

Access токен тип JWT, алгоритм SHA512, хранить в базе строго запрещено.

Refresh токен тип произвольный, формат передачи base64, хранится в базе исключительно в виде bcrypt хеша, должен быть защищен от изменения на стороне клиента и попыток повторного использования.

Access, Refresh токены обоюдно связаны, Refresh операцию для Access токена можно выполнить только тем Refresh токеном который был выдан вместе с ним.

Payload токенов должен содержать сведения об ip адресе клиента, которому он был выдан. В случае, если ip адрес изменился, при рефреш операции нужно послать email warning на почту юзера (для упрощения можно использовать моковые данные).

**Результат:**

Результат выполнения задания нужно предоставить в виде исходного кода на Github. Будет плюсом, если получится использовать Docker и покрыть код тестами.
